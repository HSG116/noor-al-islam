
import { supabase } from '../supabaseClient';
import { MemorizationPlan, PlanStrategy, DayTask, PlanScopeType } from '../types';

const PLAN_STORAGE_KEY = 'noor_hafiz_plan';
const PROGRESS_STORAGE_KEY = 'noor_hafiz_progress';

// Helper to map DB snake_case to App camelCase
const mapFromDB = (data: any): MemorizationPlan => ({
    id: data.id,
    userId: data.user_id,
    startDate: data.start_date,
    targetEndDate: data.target_end_date,
    scopeType: data.scope_type as PlanScopeType,
    startPage: data.start_page,
    endPage: data.end_page,
    strategy: data.strategy as PlanStrategy,
    pagesPerDay: Number(data.pages_per_day),
    offDays: data.off_days || [],
    memorizationStyle: data.memorization_style || 'STANDARD',
    lastPrayerCompleted: data.last_prayer_completed || 'NONE',
    reviewEnabled: data.review_enabled,
    reviewRatio: data.review_ratio,
    currentPage: data.current_page,
    completedPages: data.completed_pages,
    totalDaysElapsed: data.total_days_elapsed,
    streak: data.streak,
    backlogPages: Number(data.backlog_pages),
    lastActivityDate: data.last_activity_date
});

// Helper to map App camelCase to DB snake_case
const mapToDB = (plan: MemorizationPlan) => ({
    user_id: plan.userId,
    start_date: plan.startDate,
    target_end_date: plan.targetEndDate,
    scope_type: plan.scopeType,
    start_page: plan.startPage,
    end_page: plan.endPage,
    strategy: plan.strategy,
    pages_per_day: plan.pagesPerDay,
    off_days: plan.offDays,
    memorization_style: plan.memorizationStyle,
    last_prayer_completed: plan.lastPrayerCompleted,
    review_enabled: plan.reviewEnabled,
    review_ratio: plan.reviewRatio,
    current_page: plan.currentPage,
    completed_pages: plan.completedPages,
    total_days_elapsed: plan.totalDaysElapsed,
    streak: plan.streak,
    backlog_pages: plan.backlogPages,
    last_activity_date: plan.lastActivityDate,
    updated_at: new Date().toISOString()
});

export const plannerService = {
  
  async savePlan(plan: MemorizationPlan, userId: string, isAdvance: boolean = false) {
    // 1. Save Locally (Backup)
    localStorage.setItem(PLAN_STORAGE_KEY, JSON.stringify(plan));
    
    // 2. If no user, we are done
    if (!userId) return;

    try {
        const planWithAuthId = { ...plan, userId: userId };
        const dbPayload = mapToDB(planWithAuthId);

        // 3. Robust Save: Check if ANY plan exists for this user first
        const { data: existing, error: fetchError } = await supabase
            .from('memorization_plans')
            .select('id')
            .eq('user_id', userId)
            .maybeSingle();

        if (fetchError) console.error("Error checking existing plan:", fetchError);

        if (existing) {
             // UPDATE existing plan (Use DB ID, ignore local ID if different)
             const { error } = await supabase
                .from('memorization_plans')
                .update(dbPayload)
                .eq('id', existing.id);
             
             if (error) throw error;
        } else {
             // INSERT new plan
             // Explicitly remove 'id' if it causes issues, or ensure it matches schema
             // We use plan.id (generated by UUID) for insertion
             const { error } = await supabase
                .from('memorization_plans')
                .insert({ ...dbPayload, id: plan.id });
             
             if (error) throw error;
        }

        // 4. Logging (Optional)
        if (existing || plan.id) {
            if (isAdvance || plan.memorizationStyle !== 'PRAYERS') {
                await supabase
                    .from('plan_logs')
                    .insert({
                        user_id: userId,
                        plan_id: existing?.id || plan.id,
                        pages_completed: plan.pagesPerDay,
                        is_advance: isAdvance,
                        created_at: new Date().toISOString()
                    });
            }
        }

    } catch (e: any) {
        console.error("CRITICAL: Failed to save plan to Supabase:", e.message || e);
    }
  },

  async fetchPlan(userId: string): Promise<MemorizationPlan | null> {
    // If not logged in, try local storage
    if (!userId) {
        const data = localStorage.getItem(PLAN_STORAGE_KEY);
        return data ? JSON.parse(data) : null;
    }

    try {
        const { data, error } = await supabase
            .from('memorization_plans')
            .select('*')
            .eq('user_id', userId)
            .maybeSingle();

        if (error) throw error;
        
        if (data) {
            const mapped = mapFromDB(data);
            // Sync DB data to LocalStorage to keep them in sync
            localStorage.setItem(PLAN_STORAGE_KEY, JSON.stringify(mapped));
            
            // Check if day changed to reset prayer status
            return this.checkDayReset(mapped, userId);
        }
    } catch (e: any) {
        console.error("Failed to fetch plan from Supabase:", e.message || e);
    }

    // Fallback: If DB fetch failed or returned nothing, try local storage
    // But be careful: Local storage might belong to a different user (guest)
    // Ideally, we should clear local storage if IDs don't match, but for now we fallback.
    const local = localStorage.getItem(PLAN_STORAGE_KEY);
    return local ? JSON.parse(local) : null;
  },

  async checkDayReset(plan: MemorizationPlan, userId: string): Promise<MemorizationPlan> {
      const today = new Date();
      const lastActive = new Date(plan.lastActivityDate || 0);
      const isSameDay = lastActive.getDate() === today.getDate() && 
                        lastActive.getMonth() === today.getMonth() && 
                        lastActive.getFullYear() === today.getFullYear();
      
      if (!isSameDay && plan.memorizationStyle === 'PRAYERS') {
          const updatedPlan = { ...plan, lastPrayerCompleted: 'NONE' };
          await this.savePlan(updatedPlan, userId);
          return updatedPlan;
      }
      return plan;
  },

  getPlan(): MemorizationPlan | null {
    const data = localStorage.getItem(PLAN_STORAGE_KEY);
    return data ? JSON.parse(data) : null;
  },

  async deletePlan(userId?: string) {
    localStorage.removeItem(PLAN_STORAGE_KEY);
    localStorage.removeItem(PROGRESS_STORAGE_KEY);

    if (userId) {
        try {
            await supabase.from('memorization_plans').delete().eq('user_id', userId);
            await supabase.from('user_progress').delete().eq('user_id', userId);
            await supabase.from('plan_logs').delete().eq('user_id', userId);
        } catch (e: any) {
            console.error("Failed to delete plan/progress from DB:", e.message || e);
        }
    }
  },

  getPrayerTaskRange(plan: MemorizationPlan, prayerName: string): { start: number, end: number, isDone: boolean } {
      const prayers = ['Fajr', 'Dhuhr', 'Asr', 'Maghrib', 'Isha'];
      const prayerIndex = prayers.indexOf(prayerName);
      
      if (prayerIndex === -1) {
          return { start: plan.currentPage, end: plan.currentPage, isDone: false };
      }

      let dailyTarget = plan.pagesPerDay;
      if (plan.backlogPages > 0) dailyTarget += Math.max(0.5, plan.backlogPages / 7);
      dailyTarget = Math.ceil(dailyTarget * 2) / 2;

      const pagesPerPrayer = dailyTarget / 5;
      
      const startOffset = Math.floor(prayerIndex * pagesPerPrayer);
      let startPage = plan.currentPage + startOffset;

      let endOffset = Math.floor((prayerIndex + 1) * pagesPerPrayer) - 1;
      
      if (endOffset < startOffset) endOffset = startOffset;
      
      let endPage = plan.currentPage + endOffset;

      if (endPage > plan.endPage) endPage = plan.endPage;
      if (startPage > endPage) startPage = endPage;

      const completedIndex = prayers.indexOf(plan.lastPrayerCompleted);
      const isDone = completedIndex >= prayerIndex && plan.lastPrayerCompleted !== 'NONE';

      return { start: startPage, end: endPage, isDone };
  },

  async completePrayer(plan: MemorizationPlan, prayerName: string): Promise<MemorizationPlan> {
      const updatedPlan = {
          ...plan,
          lastPrayerCompleted: prayerName,
          lastActivityDate: new Date().toISOString()
      };
      
      if (prayerName === 'Isha') {
          return this.completeDay(updatedPlan);
      }

      return updatedPlan;
  },

  completeDay(plan: MemorizationPlan, isAdvance: boolean = false): MemorizationPlan {
    const task = this.getTodayTask(plan);
    if (!isAdvance && (task.isDone || !task.newPages)) return plan; 

    let pagesDone = 0;
    if (isAdvance) {
        let amount = plan.pagesPerDay;
        amount = Math.ceil(amount * 2) / 2;
        pagesDone = amount;
    } else {
        pagesDone = task.newPages ? (task.newPages.end - task.newPages.start + 1) : 0;
    }
    
    let newBacklog = plan.backlogPages;
    const extraWork = Math.max(0, pagesDone - plan.pagesPerDay);
    newBacklog = Math.max(0, newBacklog - extraWork);

    const nextPlan: MemorizationPlan = {
      ...plan,
      currentPage: plan.currentPage + Math.floor(pagesDone),
      completedPages: plan.completedPages + pagesDone,
      streak: plan.streak + 1,
      backlogPages: newBacklog,
      totalDaysElapsed: plan.totalDaysElapsed + 1,
      lastActivityDate: new Date().toISOString(),
      lastPrayerCompleted: 'NONE'
    };
    
    const newProjection = this.calculateProjectedEndDate(
        nextPlan.currentPage, 
        nextPlan.endPage, 
        nextPlan.pagesPerDay, 
        nextPlan.offDays, 
        nextPlan.backlogPages
    );
    nextPlan.targetEndDate = newProjection.date.toISOString();

    return nextPlan;
  },

  getReviewStatus(planId: string): boolean {
      const key = `review_done_${planId}_${new Date().toLocaleDateString()}`;
      return !!localStorage.getItem(key);
  },

  markReviewComplete(planId: string) {
      const key = `review_done_${planId}_${new Date().toLocaleDateString()}`;
      localStorage.setItem(key, 'true');
  },

  calculateProjectedEndDate(currentP: number, endP: number, rate: number, offDays: number[], backlog: number = 0): { date: Date, totalDays: number } {
    const remainingBase = Math.max(0, endP - currentP + 1);
    const totalWorkLoad = remainingBase + backlog; 
    if (totalWorkLoad <= 0) return { date: new Date(), totalDays: 0 };

    let pagesLeft = totalWorkLoad;
    let currentDate = new Date();
    let daysCount = 0;
    while (pagesLeft > 0 && daysCount < 3650) {
      currentDate.setDate(currentDate.getDate() + 1);
      daysCount++;
      const dayOfWeek = currentDate.getDay();
      if (!offDays.includes(dayOfWeek)) {
        pagesLeft -= rate;
      }
    }
    return { date: currentDate, totalDays: daysCount };
  },

  calculateRequiredRate(startP: number, endP: number, targetDate: Date, offDays: number[]): number {
    const totalPages = endP - startP + 1;
    const today = new Date();
    if (targetDate <= today) return totalPages;

    let workingDays = 0;
    let loopDate = new Date(today);
    while (loopDate < targetDate) {
      loopDate.setDate(loopDate.getDate() + 1);
      if (!offDays.includes(loopDate.getDay())) {
        workingDays++;
      }
    }
    if (workingDays === 0) return totalPages;
    const rawRate = totalPages / workingDays;
    return Math.ceil(rawRate * 10) / 10;
  },

  getTodayTask(plan: MemorizationPlan): DayTask {
    const today = new Date();
    const dayOfWeek = today.getDay();
    const isOffDay = plan.offDays.includes(dayOfWeek);

    const calculateReview = (current: number, ppd: number): {start: number, end: number} | null => {
        if (!plan.reviewEnabled || plan.reviewRatio <= 0) return null;
        const reviewCount = Math.ceil(ppd * plan.reviewRatio);
        const reviewEnd = Math.max(1, current - 1); 
        let reviewStart = Math.max(1, reviewEnd - reviewCount + 1);
        if (reviewStart < plan.startPage) reviewStart = plan.startPage;
        if (reviewEnd < reviewStart) return null;
        return { start: reviewStart, end: reviewEnd };
    }

    if (plan.currentPage > plan.endPage) {
        return { date: today.toISOString(), isOffDay: false, newPages: null, reviewPages: null, isBacklog: false, isDone: true };
    }

    const lastActive = new Date(plan.lastActivityDate || 0);
    const isSameDay = lastActive.getDate() === today.getDate() && 
                      lastActive.getMonth() === today.getMonth() && 
                      lastActive.getFullYear() === today.getFullYear();

    if (isSameDay) {
        const reviewRange = calculateReview(plan.currentPage, plan.pagesPerDay);
        let isDone = true;
        if (plan.memorizationStyle === 'PRAYERS' && plan.lastPrayerCompleted !== 'Isha') {
            isDone = true;
        }

        return {
            date: today.toISOString(), isOffDay: false, newPages: null, reviewPages: reviewRange, isBacklog: false, isDone: isDone
        };
    }

    if (isOffDay) {
      return { date: today.toISOString(), isOffDay: true, newPages: null, reviewPages: null, isBacklog: false, isDone: false };
    }

    let dailyTarget = plan.pagesPerDay;
    let isBacklogMode = false;
    if (plan.backlogPages > 0) {
      const compensationChunk = Math.max(0.5, plan.backlogPages / 7); 
      dailyTarget += compensationChunk;
      isBacklogMode = true;
    }

    dailyTarget = Math.ceil(dailyTarget * 2) / 2;
    const startNew = plan.currentPage;
    let endNew = startNew + Math.floor(dailyTarget) - 1;
    if (dailyTarget % 1 !== 0) endNew = startNew + Math.ceil(dailyTarget) - 1;
    if (endNew > plan.endPage) endNew = plan.endPage;
    const reviewRange = calculateReview(startNew, dailyTarget);

    return {
      date: today.toISOString(),
      isOffDay: false,
      newPages: { start: startNew, end: endNew },
      reviewPages: reviewRange,
      isBacklog: isBacklogMode,
      isDone: false
    };
  },

  handleEmergency(plan: MemorizationPlan, mode: 'EXTEND' | 'COMPENSATE'): MemorizationPlan {
    const missedAmount = plan.pagesPerDay;
    let newPlan = { ...plan, streak: 0, lastActivityDate: new Date().toISOString() };
    if (mode === 'COMPENSATE') newPlan.backlogPages += missedAmount;
    
    const newProjection = this.calculateProjectedEndDate(
        newPlan.currentPage, newPlan.endPage, newPlan.pagesPerDay, newPlan.offDays, newPlan.backlogPages
    );
    newPlan.targetEndDate = newProjection.date.toISOString();
    return newPlan;
  }
};
